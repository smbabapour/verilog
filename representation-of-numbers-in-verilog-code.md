# نمایش اعداد در Verilog

در Verilog می‌توان اعداد را به عنوان مقادیر ثابت به متغیرها نسبت داد. اعداد را می‌توان در مبناهای باینری \(b\) ، اوکتال \(o\) ، هگزدسیمال \(h\) و یا دسیمال \(d\) تعریف نمود. سایز اعداد می‌تواند ثابت و یا نامشخص باشد. فرمت کلی نمایش اعداد بصورت زیر است:

```
<size_in_bits>’<radix_identifier><significant_digits>
```

اندازه \(size\) یک عدد دهدهی است که تعداد بیت های مورد نیاز برای عدد را مشخص می‌کند. مبنا \(radix\) با استفاده از حروفb ،o ،h و یاd مشخص می‌شود و با توجه به این مبنا، اعداد مقدار دهی می‌شوند. برای مثال، عدد دهدهی 2217 را می‌توان با استفاده از 12 بیت به صورت زیر نمایش داد:

```
12’b100010101001
12’o4251
12’h8A9
12’d2217
```

همچنین می‌توان سایز عدد را نامشخص در نظر گرفت. برای مثال، عدد دهدهی278بصورت زیر نمایش داده می‌شود:

```
‘b100010110
‘o426
‘h116
278
```

برای اعداد دهدهی نیازی به استفاده از مبنایd برای نمایش آن ها نیست. هنگامی که اندازه‌ی یک عدد نامشخص است، کامپایلرVerilog برای آن یک اندازه‌ی ثابت و مشخص در نظر می‌گیرد، که معمولا برابر اندازه‌ی عملگر\(عملگرهای\) دیگر در عبارت است.

اعداد منفی درVerilog با قرار دادن علامت منفی \(“-“\) قبل از آن ها مشخص می‌شوند. بنابراین اگر عدد -5 بصورت

```
-4'b101
```

مشخص شود، بصورت متمم 2 ِ عدد 5 تفسیر خواهد شد که برابر 1011 می‌باشد.

ممکن است اندازه‌ی مشخص شده برای یک عدد از تعداد بیت مورد نیاز برای نمایش یک عدد تجاوز کند. یعنی برای مثال از 6 بیت برای نمایش یک عدد 4 بیتی استفاده شود. در این حالت، ذخیره سازی عدد از سمت راست شروع شده و با توجه به اندازه مشخص شده ادامه می‌یابد و بیت های اضافه نادیده گرفته می‌شود. برای نمونه عدد

```
6'ha
```

به صورت 001010 ذخیره می‌شود.

در طراحی یک مدار، اعداد به سیگنال هایی تبدیل می‌شوند که توسط سیم ها حمل شده و توسط گیت های منطقی دچار تغییرات می‌شوند. تاکنون فرض شده بود که سیگنال های موجود در یک مدار دیجیتال شامل مقادیر 0 و 1 است. درVerilog هر سیگنال می‌تواند چهار مقدار داشته باشد: 0، 1، X، Z . مقدار X به معنای یک مقدار منطقی نامشخص است که می‌تواند هر یک از مقادیر 0، 1 و یا Z باشد. برای مثال، در طراحیVerilog مقدار ثابت

```
8'hz3
```

را می‌توان به صورت

```
8'bzzzz0011
```

هم نمایش داد. مقادیر x و z را نمی‌توان در مبنای دهدهی \(d\) استفاده نمود. در همین بخش اشاره شد که اگر عددی از سایز مشخص شده کوچکتر باشد، سمت چپ آن با صفر پر می‌شود. اما اگر سمت چپ ترین مقدار یک عدد، یکی از مقادیر z یا x باشد، در سمت چپ آن عدد این مقادیر z یا x قرار می‌گیرند.

اعداد برداری با اندازه بیت های متفاوتی می‌توانند در یک عملیات حسابی استفاده شوند. فرض کنید A یک بردار 8 بیتی و B یک بردار 4 بیتی است. در این صورت عبارت

```
C = A + B;
```

یک بردار 8 بیتی بنام C را تولید می‌کند. اگر B یک عدد مثبت باشد، نتیجه عملیات بالا درست خواهد بود. اگر B یک عدد منفی باشد که بصورت متمم 2 ذخیره شده است، نتیجه عملیات بالا نادرست خواهد بود. زیرا سمت چپ B با 0 پر می‌شود تا آن را به یک عدد 8 بیتی تبدیل کند. اگر سمت چپ یک عدد مثبت 0 قرار گیرد، مقدار آن تغییر نخواهد کرد؛ و اگر سمت چپ یک عدد منفی 1 قرار گیرد، مقدار آن تغییر نخواهد کرد. به این نوع تکرار بیت علامت در اعداد، **تمدید علامت \(sign extension\) ** گویند. بنابراین برای کارایی درست عملیات، لازم است بیت علامت را در B تکرار کنیم؛ که این کار را به کمک عملگر الحاق بصورت زیر می‌توان انجام داد:

```
C = A + {4{B[3]}, B};
```

نماد 4{B\[3\]} مشخص کننده‌ی این است که بیت B\[3\] چهار بار تکرار می‌شود؛ که این کار برابر نوشتن عبارت

```
{B[3], B[3], B[3], B[3]}
```

می‌باشد. به این عملگر، عملگر **تکرار  \(Replication\)** گفته می‌شود. اگر بخواهیم سیگنال خروجی نقلی را از بیت مکان 7 استخراج نماییم، می‌توانیم از عبارت زیر استفاده کنیم:

```
C = {1’b0, A} + {1’b0, 4{B[3]}, B};
```



